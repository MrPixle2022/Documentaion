<!-- @format -->

# CRUD:

for crud operations ensure the client is installed and generated using:

```bash
pnpm i @prisma/client
# then run
pnpm prisma generate
```

for the most part any method with `Many` in the end won't actually returns the data, but how many records it read, edited, or deleted

though most have a version ending with `ManyAndReturn` -except delete- which will returns those data.

---

## Creation operation:

on the prisma client we can make use of the `create` method, this methods takes an options object, to the options we set the `data` to our record, make sure to provide every **required** field at least:

```typescript
await prisma.user.create({
	data: {
		email: "mrpixel0010@gmail.com",
		username: "pxl",
		age: 18,
		role: "admin",
	},
});
```

a quick note that a creation can be nested, when having a relation you can define the record in the data but instead of directly setting the fields you actually add the fields to the `create` option, to clear the image:

```typescript
await prisma.user.create({
	data: {
		// other fields
		userPreferences: {
			create: {
				emailUpdate: true,
			},
		},
	},
});
```

you will notice that the `userPreferences` though is supposed to be a separate model we were just able to define it inside the `create` options.

it's worth knowing that relation models can are defined as objects which has `properties` that are similar to the method that exist on the model your using -`.user` in this case- but instead of being methods they are defined as nested objects, for example you have `connect`, `create` and `createMany`, each work similar to how they would using the normal methods, also there is `

> [!IMPORTANT] if you have an existing record you want to use in this new model, make use of the `connect` option.

for example:

```typescript
const newUser = await prisma.user.create({
	data: {
		age: 18,
		email: "myNameIsAdmin@dude.com",
		username: "amr",
		userPreferences: {
			connect: { id: "86c85e41-e61c-4bca-8716-f6260e46eeba" },
		},
	},
});
```

or use the `connectOrCreate` which will look for the record and connect it, else it will simply create it:

```typescript
const newUser = await prisma.user.create({
	data: {
		age: 18,
		email: "myNameIsAdmin@dude.com",
		username: "amr",
		userPreferences: {
			connectOrCreate: {
				where: { id: "86c85e41-e61c-4bca-8716-f6260e46eeba" },
				create: { emailUpdate: true },
			},
		},
	},
});
```

> [!TIP] you can also use the `disconnect` -boolean- option to unlink the models

we can use the `createMany` to insert multiple records at once, but know that when using `createMany` both `select & include` won't work and we the `data` will be an array of objects:

```typescript
const users = await prisma.user.createMany({
	data: [{ username: "amr", email: "amr@amr.com", age: 18 }],
});
users; // {count: 1}
```

the problem is that -unlike `create`- `createMany` doesn't return the data array, but an object with the `count` of how many were inserted, though we can get those users back use `createManyAndReturn`:

```typescript
const users = await prisma.user.createManyAndReturn({
	data: [{ username: "amr", email: "amr@amr.com", age: 18 }],
});
console.log(users); //an array of users -in this case it's only one-
```

---

## Getting records:

when getting data we can either pick one, pick the first or pick many using `findUnique`, `findFirst` and `findMany` respectively, using the `where` to define the query

for example we can make use of the `findUnique` to find a single record by a **unique** field:

```typescript
const amr = await prisma.user.findUnique({
	where: {
		email_username: { email: "amr@amr.com", username: "amr" },
	},
	include: { userPreferences: false },
});
console.log("ðŸš€ ~ main ~ amr:", amr);
```

note the `email_username` object, this was actually generated by the `@@unique([email, username])` in the schema file and can be used to find a record, now that any not-unique field is invalid for this condition

ir we may use the `findFirst` which will find the very first record that meets a conation:

```typescript
const amr = await prisma.user.findFirst({
	where: { role: "Basic" },
	include: {
		password: false,
	},
});
console.log("ðŸš€ ~ main ~ amr:", amr);
```

or use `findMany` to get all records that that meets that condition:

```typescript
const users = await prisma.user.findMany({
	where: { role: "Basic" },
	include: {
		password: false,
	},
});
console.log("ðŸš€ ~ main ~ users", users);
```

---

## Updating records:

to update one or more records use the `update`, `updateMany` or `updateManyAndReturn` methods on your model, you can use a `where` for the condition and the `data` to use:

```typescript
const user = await prisma.user.update({
	where: {
		email: "pxl@amr.com",
	},
	data: {
		username: "mr_pxl",
	},
});
table(user);
```

> [!TIP] You can use a `select` and `include` on `update` & `updateManyAndReturn` not on `updateMany`, also know that when using the other two make sure to use **unique** fields

---

## Deletion:

using `delete` and `deleteMany` we can delete one or more records using a where query:

```typescript
const deleted = await prisma.user.delete({
	where: { email: "target@target.com" },
});
console.log(deleted);
```
