<!-- @format -->

# CRUD:

## Creation operation:

prisma provides `create` and `createMany` to create a one or more record, we do this by defining an options to the method and assigning the `data` object to the the new record object or an array of records objects for `createMany`:

```typescript
await prisma.user.create({
	data: {
		email: "mrpixel0010@gmail.com",
		username: "pxl",
		age: 18,
		role: "admin",
		userPreferences: {
			create: {
				emailUpdate: true,
			},
		},
	},
});
```

you will notice that the `userPreferences` though is supposed to be a separate model we were just able to define it inside the create, and by nesting another create object, that actually simplifies the process of creating records, we can replace the create with a `connect` if we have an existing record we want to link and `disconnect` -a boolean- to disconnect relations.

we also can use other options like `include` and `select`.

```typescript
const newUser = await prisma.user.create({
	// select: { username: true, id: false, email: true, userPreferences: t },
	include: { userPreferences: true },
	data: {
		email: "mrpixel0010@gmail.com",
		username: "pxl",
		age: 18,
		role: "admin",
		userPreferences: {
			create: {
				emailUpdate: true,
			},
		},
	},
});
```

by this we are making sure that we will get the new `userPreferences` object.

`select` is similar but is used to only pick certain fields only:

```typescript
const newUser = await prisma.user.create({
	select: { username: true, id: false, email: true },
	// include: { userPreferences: true },
	data: {
		email: "mrpixel0010@gmail.com",
		username: "pxl",
		age: 18,
		role: "admin",
		userPreferences: {
			create: {
				emailUpdate: true,
			},
		},
	},
});
```

by using `select` we are making sure we only get the username and email, and ignoring the id and any other field

> [!IMPORTANT] Note you can only use either `select` or `include`, and know you can nest selects and include, for example:

```typescript
select: {
  username: true,
  userPreferences: { select: { id: true } },
  email: true,
},
```

---

## Using createMany:

we can use the `createMany` to insert multiple records at once, but know that when using `createMany` both `select & include` won't work

```typescript
const users = await prisma.user.createMany({
	data: [{ username: "amr", email: "amr@amr.com", age: 18 }],
});
users; // {count: 1}
```

if you want to get those users back use ``:

```typescript
const users = await prisma.user.createManyAndReturn({
	data: [{ username: "amr", email: "amr@amr.com", age: 18 }],
});
console.log(users); //an array of users -in this case it's only one-
```

---

## Getting records:

when getting data based on a unique filed use the `findUnique`, it will look based on the `where` condition:

```typescript
const amr = await prisma.user.findUnique({
	where: {
		email_username: { email: "amr@amr.com", username: "amr" },
	},
	include: { userPreferences: false },
});
console.log("ðŸš€ ~ main ~ amr:", amr);
```

note the `email_username` object, this was actually generated by the `@@unique([email, username])` in the schema file and can be used to find a record, now that any not-unique field is invalid for this condition

though their are option like `findFirst` which will find the very first record that meets a conation:

```typescript
const amr = await prisma.user.findFirst({
	where: { role: "Basic" },
	select: {
		userPreferencesId: false,
		userPreferences: false,
		email: true,
		username: true,
	},
});
console.log("ðŸš€ ~ main ~ amr:", amr);
```

or use `findMany`:

```typescript
const users = await prisma.user.findMany({
	where: { role: "Basic" },
	select: {
		userPreferencesId: false,
		userPreferences: false,
		email: true,
		username: true,
	},
});
console.log("ðŸš€ ~ main ~ users", users);
```

in addition to the `where` we can use the `distinct` option to ignore duplicate fields:

```typescript
const distinctUsersName = await prisma.user.findMany({
	where: { role: "Basic" },
	distinct: ["username"],
});
console.table(distinctUsersName);
```

so this will select all `basic` role users whose username is **distinct**

we can go even further:

```typescript
const distinctUsersName = await prisma.user.findMany({
	where: { role: "Basic" },
	distinct: ["username"],
	take: 1, //only take one result
	skip: 1, //skip the first result
	orderBy: { age: "asc" }, //order by age ascending, or use desc for descending
});
console.table(distinctUsersName);
```

this will select all users whose role is **basic** and has a distinct **username**, take only **1** result and skip the first one, and then order the result based on the age in ascending order

---

## Advanced Where:

`where` can actually be used to handle more complex logic, for example:

```typescript
where: {
  age: { gte: 10 },
},
```

here we selection all records whose age is `>=` 10, we also have `gt` for grater than, `lt` and `lst` for less than & less than or equal, `equals` for equality & `not` for inequality , or use `in` and `notIn` to check if a field's value is a part or not part of an array:

```typescript
where: {
  age: { in: [18, 19] },
},
```

this picks all ages that are either 18 or 19

also we have the `contains`, `endsWith`, `startsWith` to check if the text value is included in a field

```typescript
const distinctUsersName = await prisma.user.findMany({
	where: {
		email: { contains: "@", startsWith: "amr" },
	},
});
console.table(distinctUsersName);
```

this will select all emails that contains `@` @any position, and start with `amr`

also we can combine conditions using thing like `AND`, `OR` & `NOT`:

```typescript
const distinctUsersName = await prisma.user.findMany({
	where: {
		AND: [{ email: { endsWith: "@amr.com" } }, { role: "Basic" }],
		OR: [{ email: { endsWith: "@gmail.com" } }],
		NOT: [{ username: { equals: "amr" } }],
	},
});
console.table(distinctUsersName);
```

---

## Updating records:

to update one or more records use the `update`, or `updateMany` methods on your model, you can use a `where` for the condition and the `data` to use:

```typescript
const user = await prisma.user.update({
	where: {
		email: "pxl@amr.com",
	},
	data: {
		username: "mr_pxl",
	},
});
table(user);
```

> [!TIP] You can use a `select` and `include` on `update` not `updateMany`, also know that when using `update` make sure to use **unique** fields

---

## Deletion:

using `delete` and `deleteMany` we can delete one or more records:

```typescript
const deleted = await prisma.user.delete({
	where: { email: "target@target.com" },
});
console.log(deleted);
```
